Language Specification - CS355 Compiler Project - Ethan Rutherford and Roger Gee
--------------------------------------------------------------------------------
This document describes the specification for the 'Ramsey' language.
--------------------------------------------------------------------------------
A. Keywords

   - keywords are lowercase

[keywords]
   in, boo, fun, endfun, toss, and, or, not, if, elf, endif, take, give, true,
false, while, smash, endwhile
--------------------------------------------------------------------------------
B. Preprocessing

   - Comments: we replace each comment with a newline token

--------------------------------------------------------------------------------
C. Lexical Conventions

   - here we present conventions for grammar productions
   - we use (?) to mean that we are considering adding the convention

token:
        identifier
        keyword
        literal
        operator
        punctuator

digit: one of
        0 1 2 3 4 5 6 7 8 9

hex-digit: one of
        0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f

non-digit: one of
        a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K
L M N O P Q R S T U V W X Y Z _

literal:
        integer-literal
        character-literal (?)
        string-literal (?)
        boolean-literal

integer-literal:
        decimal-literal
        hexadecimal-literal (?)

decimal-literal:
        digit
        decimal-literal digit

hexadecimal-literal:
        0x hex-digit
        0X hex-digit
        hexadecimal-literal hex-digit

boolean-literal:
        true
        false

identifier:
        non-digit
        identifier nondigit
        identifier digit

keyword:
        if
        elf
        endif
        fun
        as
        toss
        endfun
        while
        smash
        endwhile
        give
        take
        in
        boo
        mod
        and
        or
        not

operator:
        + - * / < > <= >= = != <-

punctuator:
        newline
        ,
        ( )
        [ ]

newline                                 --we count LFs as logical lines for error reporting
        (ASCII) 0x0A
        (ASCII) 0x0D
        (ASCII) 0x0A newline
        (ASCII) 0x0D newline
--------------------------------------------------------------------------------
D. Grammar

   - here we present a context-free grammar for Ramsey; this grammar employs 
lexical conventions defined in the previous section (B)

   - conventions used in this specification:
     <nonterminal>          grammar element that is a non-terminal construct
     [terminal]             grammar element that is one of a class of terminal constructs (usually a token)
     "literal-terminal"     grammar element that is a terminal construct exactly as seen
     ""                     empty element (epsilon)

<program>:                                --we demand at least one non-empty statement
        <non-empty-statement>
        <program-body-parts> <non-empty-statement>

<program-body-parts>:
        <function>
        <statement-list>
        <function> <program-body-parts>
        <statement-list> <program-body-parts>

<function>:
        <function-declaration> [newline] <statement-list> "endfun" [newline]

<function-declaration>:
        "fun" [identifier] "(" ")" <function-type-specifier>
        "fun" [identifier] "(" <parameter-declaration> ")" <function-type-specifier>

<function-type-specifier>:
        ""                              --default "in" type function
        "as" <typename>                 --explicit function typing

<parameter-declaration>:
        <typename> [identifier]
        <typename> [identifier] "," <parameter-declaration>

<statement>:                                    --each statement kind is separated by a newline
        ""                                      --empty statement (probably not needed)
        <declaration-statement>
        <expression-statement>
        <selection-statement>
        <iterative-statement>
        <io-statement>
        <jump-statement>

<non-empty-statement>:
        <declaration-statement>
        <expression-statement>
        <selection-statement>
        <iterative-statement>
        <io-statement>
        <jump-statement>

<statement-list>:
        <statement>
        <statement> <statement-list>

<declaration-statement>:
        <typename> [identifier] [newline]
        <typename> [identifier] <initializer> [newline]

<typename>:
        "in"
        "boo"

<initializer>:
        <assignment-operator> <expression>
        "[" [integer-literal] "]"                       --we allow primitive arrays; no member initialization though

<assignment-operator>:
        "<-"

<expression-statement>:
        <expression> [newline]

<expression>:
        <assignment-expression>

<expression-list>
        <expression>
        <expression-list> "," <expression>

<assignment-expression>:
        <logical-or-expression>
        <logical-or-expression> <assignment-operator> <assignment-expression>

<logical-or-expression>:
        <logical-and-expression>
        <logical-or-expression> "or" <logical-and-expression>

<logical-and-expression>:
        <equality-expression>
        <logical-and-expression> "and" <equality-expression>

<equality-expression>:
        <relational-expression>
        <equality-expression> "=" <relational-expression>
        <equality-expression> "!=" <relational-expression>

<relational-expression>:
        <additive-expression>
        <relational-expression> "<" <additive-expression>
        <relational-expression> ">" <additive-expression>
        <relational-expression> "<=" <additive-expression>
        <relational-expression> ">=" <additive-expression>

<additive-expression>:
        <multiplicative-expression>
        <additive-expression> "+" <multiplicative-expression>
        <additive-expression> "-" <multiplicative-expression>

<multiplicative-expression>:
        <prefix-expression>
        <multiplicative-expression> "*" <postfix-expression>
        <multiplicative-expression> "/" <postfix-expression>

<prefix-expression>
        <postfix-expression>
        "not" <prefix-expression>

<postfix-expression>:
        <primary-expression>
        <postfix-expression> "[" <expression> "]"               --array subscripting
        <postfix-expression> "(" <expression-list> ")"          --function calls

<primary-expression>:
        [literal]
        [identifier]
        "(" <expression> ")"

<selection-statement>:
        "if" "(" <condition> ")" [newline] <if-body> "endif" [newline]
        "if" "(" <condition> ")" [newline] <if-body> "else" <statement-list> "endif" [newline]

<if-body>:
        <statement-list>
        <if-body> "elf" "(" <condition> ")" [newline] <statement-list>

<condition>:                                  --just an alias for expression
        <expression>

<iterative-statement>:
        "while" "(" <condition> ")" [newline] <statement-list> "endwhile" [newline]

<io-statement>:
        "give" <expression> [newline]
        "take" <expression> [newline]

<jump-statement>:
        "toss" <expression> [newline]                   --note, there is no concept of void, so we demand that something need be returned
        "smash" [newline]                               --a Ramsefied version of break; ends the execution of the nearest loop
--------------------------------------------------------------------------------
